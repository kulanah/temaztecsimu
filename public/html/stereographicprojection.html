<html>
	<head>
		<title>Stereographic Projection</title>
		<style>
			body { margin: 0; }
      canvas { width: 100%; height: 100% }
      #info {
        position: absolute;
        top: 5px;
        left: 5px;
        z-index: 100;
        color: white;
      }
      input{
				width: 80px;
			}
			label {
				display:inline-block;
				width:50px;
				text-align:right;
      }
		</style>
	</head>
	<body>
    <div id="info">
      Stereographic Projection<br><br>
      <label for='radius'>radius:</label>
      <input id='radius' type='number' value='1' min='0' oninput='update()'><br>
      <label for='alphatilt'>α tilt:</label>
      <input id='alphatilt' type='number' value='0' oninput='update()'><br>
      <label for='betatilt'>β tilt:</label>
      <input id='betatilt' type='number' value='0' oninput='update()'><br>
      <label for='u'>u:</label>
      <input id='u' type='number'value='1' oninput='update()'><br>
      <label for='v'>v:</label>
      <input id='v' type='number' value='0' oninput='update()'><br>
      <label for='w'>w:</label>
      <input id='w' type='number' value='0' oninput='update()'>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 70, window.innerWidth/window.innerHeight, 0.01, 1000 );

			var renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

      let radius = 1,
      width = Math.PI / 360,
      material = new THREE.MeshBasicMaterial( { color: 0x00ff88 } ),
      geometry = new THREE.TorusGeometry( radius, width, 8, 100 );

      let pattern = [];
      for (let i = 0; i < 4; i++){
        for (let j = 0; j < 4; j++){
          var band = new THREE.Mesh( geometry, material );
          scene.add( band );
          band.rotation.x = Math.PI / 4 * i;
          band.rotation.y = Math.PI / 4 * j;
          pattern.push(band);
        }
      }

      camera.position.z = 5;
      renderer.render(scene, camera);

      var mouseDown = false;
      document.body.onmousedown = function() { 
        mouseDown = true;
      }
      document.body.onmouseup = function() {
        mouseDown = false;
      }

      function update(){
        for(let band in pattern){
          scene.remove(pattern[band]);
        }
        radius = Number(document.getElementById('radius').value),
        width =  radius * Math.PI / 360,
        material = new THREE.MeshBasicMaterial( { color: 0x00ff88 } ),
        geometry = new THREE.TorusGeometry( radius, width, 8, 100 );

        pattern = [];
        for (let i = 0; i < 4; i++){
          for (let j = 0; j < 4; j++){
            var band = new THREE.Mesh( geometry, material );
            scene.add( band );
            band.rotation.x = Math.PI / 4 * i + Math.PI / 180 * document.getElementById('alphatilt').value;
            band.rotation.y = Math.PI / 4 * j + Math.PI / 180 * document.getElementById('betatilt').value;
            pattern.push(band);
          }
        }

        renderer.render(scene, camera);
      }

			var animate = function () {
        requestAnimationFrame( animate );
        for(let band in pattern){
          if(mouseDown){
            pattern[band].rotation.y += .01;
          } else {
            pattern[band].rotation.x += .01;
          }
        }

				renderer.render(scene, camera);
      };

      // Function from https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_cloth.html
      function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        update();
			}

      window.addEventListener( 'resize', onWindowResize, false );

			//animate();
		</script>
	</body>
</html>