<html>
	<head>
		<title>Stereographic Projection</title>
		<style>
			body { margin: 0; }
      canvas { width: 100%; height: 100% }
      #info {
        position: absolute;
        top: 5px;
        left: 5px;
        z-index: 100;
        color: white;
      }
      input{
				width: 50px;
			}
			label {
				display:inline-block;
				width:100px;
				text-align:right;
      }
		</style>
	</head>
	<body>
    <div id="info">
      Stereographic Projection<br><br>
      <label for='radius'>Sphere radius:</label>
      <input id='radius' type='number' value='10' min='1' oninput='update()'><br>
      <label for='width'>Band width:</label>
      <input id='width' type='number' value='0.5' min='0.1' step='0.1' oninput='update()'>°<br>
      <label for='alphatilt'>α tilt:</label>
      <input id='alphatilt' type='number' value='0' oninput='update()'>°<br>
      <label for='betatilt'>β tilt:</label>
      <input id='betatilt' type='number' value='0' oninput='update()'>°<br>
      <label for='u'>u:</label>
      <input id='u' type='number'value='1' oninput='update()'><br>
      <label for='v'>v:</label>
      <input id='v' type='number' value='0' oninput='update()'><br>
      <label for='w'>w:</label>
      <input id='w' type='number' value='0' oninput='update()'>
      <p>The mouse is over: ()</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 70, window.innerWidth/window.innerHeight, 0.01, 1000 );

			var renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

      let pattern = [];
      let cameraDistance = 50;
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2(), INTERSECTED;
      update();

      function update(){
        for(let band in pattern){
          scene.remove(pattern[band]);
        }
        pattern = [];
        let radius = Number(document.getElementById('radius').value),
        width =  radius * document.getElementById('width').value * Math.PI / 180,
        geometry = new THREE.TorusGeometry( radius, width, 8, 100 );

        for (let i = 0; i < 2; i++){
          for (let j = 0; j < 2; j++){
            if(i === 1 && j === 1){
              // Avoid drawing (0, 1, 0) circle twice
              continue;
            } 
            let material = new THREE.MeshBasicMaterial( { color: 'silver', transparent: true, opacity: .5 } );
            var band = new THREE.Mesh( geometry, material );
            scene.add( band );
            band.rotation.x = Math.PI / 2 * i + Math.PI / 180 * document.getElementById('alphatilt').value;
            band.rotation.y = Math.PI / 2 * j + Math.PI / 180 * document.getElementById('betatilt').value;
            pattern.push(band);
          }
        }

        geometry = new THREE.TorusGeometry( radius, width * Math.sqrt(2), 8, 100 );

        for (let i = 0; i < 4; i++){
          for (let j = 0; j < 4; j++){
            if(i > 0 && j === 2){
              // Avoid drawing (0, 1, 0) circle multiple times
              continue;
            } 
            let material = new THREE.MeshBasicMaterial( { color: 'silver', transparent: true, opacity: .5 / Math.sqrt(2) } );
            var band = new THREE.Mesh( geometry, material );
            scene.add( band );
            band.rotation.x = Math.PI / 4 * i + Math.PI / 180 * document.getElementById('alphatilt').value;
            band.rotation.y = Math.PI / 4 * j + Math.PI / 180 * document.getElementById('betatilt').value;
            pattern.push(band);
          }
        }

        let u = Number(document.getElementById('u').value);
        let v = Number(document.getElementById('v').value);
        let w = Number(document.getElementById('w').value);
        let sum = Math.sqrt(u ** 2 + v ** 2 + w ** 2);
        // Positions: x = right, y = up, z = back
        // Rotations: x = up, y = left, z = twist
        camera.position.x = cameraDistance * v / sum;
        camera.position.y = cameraDistance * w / sum;
        camera.position.z = cameraDistance * u / sum;
        if(u < 0){
          camera.rotation.y = -Math.asin(v/sum) + Math.PI;
          camera.rotation.x = Math.asin(w/Math.sqrt(u**2 + w**2));
        } else if(u === 0 && w === 0){
          camera.rotation.y = Math.PI / 2 * Math.sign(v);
          camera.rotation.x = 0;
        } else {
          camera.rotation.y = Math.asin(v/sum);
          camera.rotation.x = -Math.asin(w/Math.sqrt(u**2 + w**2));
        }
        renderer.render(scene, camera);
        // update the picking ray with the camera and mouse position
				raycaster.setFromCamera( mouse, camera );

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects( pattern );
        console.log(intersects);
        for ( var i = 0; i < intersects.length; i++ ) {

          intersects[0].object.material.color.set( 0xff0000 );

        }
        renderer.render(scene, camera);
      }

      // Function from https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_cloth.html
      function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        update();
			}

      window.addEventListener( 'resize', onWindowResize, false );

      function onMouseWheel(event) {
        cameraDistance += event.deltaY / 100;
        //document.getElementById('radius').value = Math.max(1, Number(document.getElementById('radius').value) - event.deltaY / 100);
        update();
      }

      renderer.domElement.addEventListener('wheel', onMouseWheel, false);

      function onMouseMove( event ) {

        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        update();
      }

      window.addEventListener( 'mousemove', onMouseMove, false );

		</script>
	</body>
</html>