<html>
	<head>
		<title>Stereographic Projection</title>
		<style>
			body { margin: 0; }
      canvas { width: 100%; height: 100% }
      #info {
        position: absolute;
        top: 5px;
        left: 5px;
        z-index: 100;
        color: white;
      }
      input{
				width: 50px;
			}
			label {
				display:inline-block;
				width:100px;
				text-align:right;
      }
		</style>
	</head>
	<body>
    <div id="info">
      Stereographic Projection<br><br>
      Use the mouse wheel to zoom in and out<br><br>
      <label for='radius'>Sphere radius:</label>
      <input id='radius' type='number' value='10' min='1' oninput='setRadiusAndWidth()'><br>
      <label for='width'>Band width:</label>
      <input id='width' type='number' value='0.05' min='0.01' step='0.01' oninput='setRadiusAndWidth()'>°<br>
      <label for='alphatilt'>α tilt:</label>
      <input id='alphatilt' type='number' value='0' min='-45' max='45' oninput='update()'>°<br>
      <label for='betatilt'>β tilt:</label>
      <input id='betatilt' type='number' value='0' min='-20' max='20' oninput='update()'>°<br>
      <label for='u'>u:</label>
      <input id='u' type='number'value='1' oninput='update()'><br>
      <label for='v'>v:</label>
      <input id='v' type='number' value='0' oninput='update()'><br>
      <label for='w'>w:</label>
      <input id='w' type='number' value='0' oninput='update()'>
      <p id='hoverlabel'></p>
      <!--p id='xrotation'></p>
      <p id='yrotation'></p-->
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 70, window.innerWidth/window.innerHeight, 0.01, 1000 );

			var renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

      let sphere = new THREE.Group();
      scene.add(sphere);
      let pattern = [];
      let geometries = [];
      let cameraDistance = 20;
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      
      // Register the mouse as off the sphere during the initial load
      mouse.x = 1;
      mouse.y = 1;

      setRadiusAndWidth();

      function setRadiusAndWidth(){
        geometries = [];
        let radius = Number(document.getElementById('radius').value);
        let width = radius * document.getElementById('width').value * Math.PI / 180;
        for(let i = 1; i < 16; i++){
          let geometry = new THREE.TorusGeometry( radius, width * Math.sqrt(i), 8, 100 );
          geometries.push(geometry);
        }
        update();
      }

      function addBands(max){
        const OPACITY = .5;
        let u, v, w;
        for(u = -max; u <= max; u++){
          for(v = -max; v <= max; v++){
            for(w = -max; w <= max; w++){
              // The following conditionals are designed to make sure that each band gets drawn exactly once, for consistent appearance and labeling and better performance
              if(Math.abs(u) < max && Math.abs(v) < max && Math.abs(w) < max){
                continue;
              }
              if(u + v + w < 0){
                continue;
              }
              if(u + v + w === 0){
                if(u < 0){
                  continue;
                }
                if(u === 0 && v < 0){
                  continue;
                }
              }
              let sum = Math.sqrt(u ** 2 + v ** 2 + w ** 2);
              if(sum >= 4){
                continue;
              }
              let material = new THREE.MeshBasicMaterial( { color: 'silver', transparent: true, opacity: OPACITY / sum } ); 
              band = new THREE.Mesh( geometries[u ** 2 + v ** 2 + w ** 2 - 1], material );
              sphere.add(band);
              pattern.push(band);
              if(u < 0){
                band.rotation.y = -Math.asin(v/sum) + Math.PI;
                band.rotation.x = Math.asin(w/Math.sqrt(u**2 + w**2));
              } else if(u === 0 && w === 0){
                band.rotation.y = Math.PI / 2 * Math.sign(v);
                band.rotation.x = 0;
              } else {
                band.rotation.y = Math.asin(v/sum);
                band.rotation.x = -Math.asin(w/Math.sqrt(u**2 + w**2));
              }
              band.name = u + ', ' + v + ', ' + w; 
            }
          }
        }
      }

      function update(){
        for(let band in pattern){
          sphere.remove(pattern[band]);
          scene.remove(pattern[band]);
        }
        pattern = [];
        // Draw bands with smaller values first to ensure they get displayed
        addBands(1);
        addBands(2);
        addBands(3);

        let alphaTilt = Math.PI / 180 * document.getElementById('alphatilt').value;
        let betaTilt = Math.PI / 180 * document.getElementById('betatilt').value;
        sphere.rotation.x = alphaTilt;
        sphere.rotation.y = betaTilt;

        let u = Number(document.getElementById('u').value);
        let v = Number(document.getElementById('v').value);
        let w = Number(document.getElementById('w').value);
        let sum = Math.sqrt(u ** 2 + v ** 2 + w ** 2);
        // Positions: x = right, y = up, z = back
        // Rotations: x = up, y = left, z = twist
        camera.position.x = cameraDistance * v / sum;
        camera.position.y = cameraDistance * w / sum;
        camera.position.z = cameraDistance * u / sum;
        if(u < 0){
          camera.rotation.y = -Math.asin(v/sum) + Math.PI;
          camera.rotation.x = Math.asin(w/Math.sqrt(u**2 + w**2));
        } else if(u === 0 && w === 0){
          camera.rotation.y = Math.PI / 2 * Math.sign(v);
          camera.rotation.x = 0;
        } else {
          camera.rotation.y = Math.asin(v/sum);
          camera.rotation.x = -Math.asin(w/Math.sqrt(u**2 + w**2));
        }
        // render the scene so raycaster detects rotations
        renderer.render(scene, camera);
        // update the picking ray with the camera and mouse position
				raycaster.setFromCamera( mouse, camera );
        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects( sphere.children );
        console.log(intersects);
        if(intersects.length > 0) {
          intersects[0].object.material.color.set( 0xff0000 );
          let axis = intersects[0].object.name;
          document.getElementById('hoverlabel').textContent = 'The mouse is over: (' + axis + ')';
          //document.getElementById('xrotation').textContent = 'x rotation: ' + intersects[0].object.rotation.x.toFixed(2);
          //document.getElementById('yrotation').textContent = 'y rotation: ' + intersects[0].object.rotation.y.toFixed(2);
        } else {
          document.getElementById('hoverlabel').textContent = 'The mouse is over:';
          //document.getElementById('xrotation').textContent = 'x rotation:';
          //document.getElementById('yrotation').textContent = 'y rotation:';
        }
        renderer.render(scene, camera);
      }

      // Function from https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_cloth.html
      function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        update();
			}

      window.addEventListener( 'resize', onWindowResize, false );

      function onMouseWheel(event) {
        cameraDistance += event.deltaY / 100;
        update();
      }

      renderer.domElement.addEventListener('wheel', onMouseWheel, false);

      function onMouseMove( event ) {

        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        update();
      }

      window.addEventListener( 'mousemove', onMouseMove, false );

		</script>
	</body>
</html>